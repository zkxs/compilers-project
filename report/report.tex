\documentclass[paper=letter, fontsize=11pt, oneside, titlepage]{scrartcl}

\usepackage[T1]{fontenc} % 8-bit encoding using fonts that have 256 glyphs
\usepackage{beramono} % A version of Bitstream Vera Mono slightly enhanced for use with TEX
\usepackage{listings} % Required for \lstinputlisting
\usepackage{xcolor} % Required for \definecolor
\usepackage[font=bf,skip=\baselineskip]{caption} % used to set caption style
%\usepackage{sectsty} % Allows customizing section commands
\usepackage{fancyhdr} % Custom headers and footers
\usepackage{nameref} % reference named things by labels. Must be imported before hyperref
\usepackage{hyperref} % allows creation of hyperlinks
\usepackage{enumitem} % for tinkering with spacing between list items


% ------------------------------------------------------------------------------
% Set up page

\addtolength{\textheight}{0.5 in} % make bottom margin a bit smaller

% make side margins a bit smaller
\addtolength{\oddsidemargin}{-0.1in}
\addtolength{\evensidemargin}{-0.1in}
\addtolength{\textwidth}{0.2in}

\setlength\parindent{0pt} % Removes all indentation from paragraphs
\setlength{\parskip}{1em} % Set spacing before paragraphs

\setlist{noitemsep}

% ------------------------------------------------------------------------------
% Set up sections

%\allsectionsfont{\centering} % Make all sections centered


% ------------------------------------------------------------------------------
% Set up code listings

\captionsetup[lstlisting]{font={footnotesize,tt}}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{myStyle}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=true,
  columns=flexible,
  basicstyle={\footnotesize\ttfamily}, % gives us at least 80 characters per line
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  rulecolor=\color{black},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  keepspaces=true,
}

\newcommand{\scalalisting}[2][]{
    \lstinputlisting[style=myStyle, language=scala, caption={\texttt{\detokenize{#2}}},#1]{../src/#2}
}

\newcommand{\datalisting}[2][]{
    \lstinputlisting[style=myStyle, caption={\texttt{\detokenize{#2}}},#1]{../#2}
}

\newcommand{\filelisting}[2][]{
    \lstinputlisting[style=myStyle, title={\texttt{\detokenize{#2}}},#1]{../#2}
}


% ------------------------------------------------------------------------------
% Set up title

\newcommand{\ptitle}{Project 2 Report}
\newcommand{\pauthor}{Michael Ripley}
\newcommand{\pschool}{University of Tulsa}
\newcommand{\pteacher}{Dr. Shenoi}
\newcommand{\pclass}{CS-4013-01: Compiler Construction}
\newcommand{\pdate}{\today}

% Create horizontal rule command with 1 argument of height
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 

\title{
\vspace{1.8 in} \normalfont \normalsize 
\textsc{\pschool} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge \ptitle \\ % The assignment title
\horrule{0.5pt} \\[0.5cm] % Thick bottom horizontal rule
}
\author{\pauthor} % Your name
\date{
    \normalsize
    \pteacher \endgraf
    \pclass \endgraf
    \pdate
} % Today's date or a custom date


% ------------------------------------------------------------------------------
% Set up headers and footers


\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header


% ------------------------------------------------------------------------------
% Set up hyperref (pdf metadata and hyperlinks)

\hypersetup{
    colorlinks          =    {true},        % hyperlinks will be colored
    urlcolor            =    {Blue},        % url hyperlinks will be blue
    urlbordercolor      =    {0 0 1},       % url borders will be blue
    linkcolor           =    {Black},       % link color is black
    linkbordercolor     =    {0 0 0},       % link border is black
    pdftitle            =    {\ptitle}, 
    pdfauthor           =    {\pauthor},
    pdfcreator          =    {\pauthor},
    pdfproducer         =    {pdfLaTeX},
    pdfdisplaydoctitle  =    {true},
    pdfkeywords         =    {\pauthor} {Assignment} {Computer Science} {Compiler},
    bookmarks           =    {true},
    bookmarksopen       =    {false},
    pdfpagemode         =    {UseNone}
}


\begin{document}

\pdfbookmark[1]{Title Page}{title} % Add PDF bookmark to top of document

\maketitle

\section{Introduction}\label{intro}

Project 2 adds syntax analysis on top of the lexing framework created in project 1.  The syntax analyzer identifies and reports syntax errors.  Additionally, it implements error recovery.  

\section{Methodology}\label{meth}

Before work on the parser could even begin, the grammar had to undergo significant massaging.  Finally, after all massaging, the firsts and follows had to be computed.  The grammar after each step is included at the end of this report.  The steps are as follows: 
\begin{enumerate}
  \item Project-specific modifications applied and all productions split
  \item Removal of $\epsilon$ productions
  \item Removal of left recursion
  \item Left factoring, final clean-up, and computation of firsts and follows
\end{enumerate}

Using the final massaged grammar with firsts and follows, the parse table is created.  Note that while normally only the follows of $\epsilon$ productions must be computed, we need all of the follows for use in error recovery, which will be discussed later.  

Next, ambiguity must be removed.  The easiest way to do this is in the parse table.  Ambiguities appear as cells with two possible productions, one of which must be removed to resolve the ambiguity.  The \textit{optional\_else} production upon seeing terminal \textbf{else} becomes either \textbf{else} \textit{statement} OR \textbf{$\epsilon$}. The $\epsilon$ production is removed, as we want dangling-else clauses to bind to the nearest if statement.  

\section{Implementation}\label{impl}

With all the pen-and-paper work complete, let us move on to the actual implementation.  First, I reviewed the project 3 and 4 assignment to ensure that my program would be structured in such a way to be easily extended for later projects.  Then, I began the grunt work of transcribing the parse table to the recursive descent parser functions as discussed in class.  To accelerate this process and reduce redundant code, I developed a number of helper functions for common tasks, such as token comparison and error handling.  After the initial parser code was complete, I performed a second pass to add error handling to each function.  Next, I created a unique sync set for each production using the follows of that production as well as \$ (End of File).  Wrapping up, a few bugs were fixed and I plugged the new parser code into the existing lexer code.  This required a small reworking of where the printing happened.  

\section{Discussion and Conclusions}\label{conclusions}

The recursive descent parser is pretty amazing.  Testing it was actually quite entertaining, as it's starting to feel like an actual compiler.  I also noticed that most of the immediately-recursive functions are in fact tail recursive, meaning it is even more memory efficient than it appears to be.  

\section{References}\label{ref}

\begin{itemize}
    \item Handouts and lecture notes from class
    \item API documentation for both Java and Scala
    \item Discussions between myself, Steven Buchele, and James Rogers
\end{itemize}

\section{Appendix I: Sample Inputs and Outputs}\label{sample}

Two source programs were ran through the parser. The first, ``test1\_correct.pas'', has no errors.  The second, ``test2\_error.pas'', demonstrates that lexical and syntax errors are reported on and recovered from.  

\filelisting[language=pascal]{test1_correct.pas}
\filelisting{test1_correct.pas.listing}
\filelisting{test1_correct.pas.tokens}
%\filelisting[language=pascal]{test2_errors.pas}
%\filelisting{test2_errors.pas.listing}
%\filelisting{test2_errors.pas.tokens}

\section{Appendix II: Program Listings}\label{code}

\datalisting{resources/operators.dat}
\datalisting{resources/punctuation.dat}
\datalisting{resources/reservedwords.dat}

\scalalisting{net/michaelripley/pascalcompiler/Compiler.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/Identifier.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/IdentifierError.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/IdentifierManager.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/SubProgram.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/Type.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/TypedIdentifier.scala}
\scalalisting{net/michaelripley/pascalcompiler/lexer/Lexeme.scala}
\scalalisting{net/michaelripley/pascalcompiler/lexer/Lexer.scala}
\scalalisting{net/michaelripley/pascalcompiler/lexer/LineFragment.scala}
\scalalisting{net/michaelripley/pascalcompiler/lexer/LineLocation.scala}
\scalalisting{net/michaelripley/pascalcompiler/lexer/ReservedStrings.scala}
\scalalisting{net/michaelripley/pascalcompiler/parser/Parser.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/CatchAllTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/CompoundTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/SimpleTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/StringTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/Tokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/WordTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/AttributeToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/ErrorToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/IdentifierToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/IntegerToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/PartialAttributeToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/PartialErrorToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/Token.scala}
\scalalisting{net/michaelripley/Util.scala}

\end{document}
