\documentclass[paper=letter, fontsize=11pt, oneside, titlepage]{scrartcl}

\usepackage[T1]{fontenc} % 8-bit encoding using fonts that have 256 glyphs
\usepackage{beramono} % A version of Bitstream Vera Mono slightly enhanced for use with TEX
\usepackage{listings} % Required for \lstinputlisting
\usepackage{xcolor} % Required for \definecolor
\usepackage[font=bf,skip=\baselineskip]{caption} % used to set caption style
%\usepackage{sectsty} % Allows customizing section commands
\usepackage{fancyhdr} % Custom headers and footers
\usepackage{nameref} % reference named things by labels. Must be imported before hyperref
\usepackage{hyperref} % allows creation of hyperlinks
\usepackage{enumitem} % for tinkering with spacing between list items


% ------------------------------------------------------------------------------
% Set up page

\addtolength{\textheight}{0.5 in} % make bottom margin a bit smaller

% make side margins a bit smaller
\addtolength{\oddsidemargin}{-0.1in}
\addtolength{\evensidemargin}{-0.1in}
\addtolength{\textwidth}{0.2in}

\setlength\parindent{0pt} % Removes all indentation from paragraphs
\setlength{\parskip}{1em} % Set spacing before paragraphs

\setlist{noitemsep}

% ------------------------------------------------------------------------------
% Set up sections

%\allsectionsfont{\centering} % Make all sections centered


% ------------------------------------------------------------------------------
% Set up code listings

\captionsetup[lstlisting]{font={footnotesize,tt}}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{myStyle}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=true,
  columns=flexible,
  basicstyle={\footnotesize\ttfamily}, % gives us at least 80 characters per line
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  rulecolor=\color{black},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  keepspaces=true,
}

\newcommand{\scalalisting}[2][]{
    \lstinputlisting[style=myStyle, language=scala, caption={\texttt{\detokenize{#2}}},#1]{../src/#2}
}

\newcommand{\datalisting}[2][]{
    \lstinputlisting[style=myStyle, caption={\texttt{\detokenize{#2}}},#1]{../#2}
}

\newcommand{\filelisting}[2][]{
    \lstinputlisting[style=myStyle, title={\texttt{\detokenize{#2}}},#1]{../#2}
}


% ------------------------------------------------------------------------------
% Set up title

\newcommand{\ptitle}{Project 1 Report}
\newcommand{\pauthor}{Michael Ripley}
\newcommand{\pschool}{University of Tulsa}
\newcommand{\pteacher}{Dr. Shenoi}
\newcommand{\pclass}{CS-4013-01: Compiler Construction}
\newcommand{\pdate}{\today} %TODO: use \today

% Create horizontal rule command with 1 argument of height
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 

\title{
\vspace{1.8 in} \normalfont \normalsize 
\textsc{\pschool} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge \ptitle \\ % The assignment title
\horrule{0.5pt} \\[0.5cm] % Thick bottom horizontal rule
}
\author{\pauthor} % Your name
\date{
    \normalsize
    \pteacher \endgraf
    \pclass \endgraf
    \pdate
} % Today's date or a custom date


% ------------------------------------------------------------------------------
% Set up headers and footers


\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header


% ------------------------------------------------------------------------------
% Set up hyperef (pdf metadata and hyperlinks)

\hypersetup{
    colorlinks          =    {true},        % hyperlinks will be colored
    urlcolor            =    {Blue},        % url hyperlinks will be blue
    urlbordercolor      =    {0 0 1},       % url borders will be blue
    linkcolor           =    {Black},       % link color is black
    linkbordercolor     =    {0 0 0},       % link border is black
    pdftitle            =    {\ptitle}, 
    pdfauthor           =    {\pauthor},
    pdfcreator          =    {\pauthor},
    pdfproducer         =    {pdfLaTeX},
    pdfdisplaydoctitle  =    {true},
    pdfkeywords         =    {\pauthor} {Assignment} {Computer Science} {Compiler},
    bookmarks           =    {true},
    bookmarksopen       =    {false},
    pdfpagemode         =    {UseNone}
}


\begin{document}

\pdfbookmark[1]{Title Page}{title} % Add PDF bookmark to to of document

\maketitle

\section{Introduction}\label{intro}

Project 1 is the implementation of a lexical analyzer for a subset of Pascal.  The lexical analyzer tokenizes an input file and detects lexical errors.  Additionally, a symbol table is created during lexical analysis.

\section{Methodology}\label{meth}

A source file is read in line-by-line. Each line is examined by several machines. If a machine matches the beginning of that line, it is captured as a token. The rest of the line is then examined by the machines again and again, until the end of the line. The tokens output by the machines contain the lexeme, the token name, and then either an attribute or an identifier. The identifiers are references to a symbol in the symbol table. Finally, an EOF token is inserted at the end of the file.

\subsection{Machines}\label{machines}

The meat and potatoes of the lexical analyzer is several machines.

The first machine matches words, which are checked against a reserved-word table. If a match is found, the token is clearly a reserved word, otherwise it is an identifier.  Identifiers can be at most 10 characters long.

Next, there are three types of numbers: Long reals, reals, and integers, which should be checked for in that order, otherwise part of a real may be stolen to make an integer token.

Finally, there is a catch-all machine that will grab a single character. As this single character was not recognized by any other machine, it is an unrecognized character lexical error.

\section{Implementation}\label{impl}

I chose to use Scala as the main programming language for this project.  Scala compiles to JVM bytecode, meaning it can run anywhere Java can, and it can seamlessly make calls to Java libraries.  It sort of fits into the ``better Java'' niche, aiming to have all of Java's strong points while incorporating more modern language features.

My decision to use Scala was made for several reasons.  While the language I am most comfortable with is Java, I've been interested in Scala for a while and I feel I won't learn it unless I make a write a large project using it.  As I am already familiar with C, pointers, and manual memory management, I felt that I could use this opportunity better learning a new language than than revisiting all the pointer aritmetic and memory management of my past experiences.  

Due to the size of this project, it merited doing a certain amount of planning ahead of time.  I drew out a flow chart of the general structure of the major components of the program, then made some pseudocode to help my wrap my mind around how the machines would be called.  I could have done more planning ahead of time, which would have saved me some time as I scrapped some work that was going down the wrong path.

When working on a large project, I like to begin with the smallest pieces possible, gradually combining them as I add functionality.  I've noticed that when programming in this order, I have more opportunity to notice flaws in my initial design and adjust before I've invested too much time in them.

I began by defining the simple data elements, such as tokens and lexemes. Working my way up, I began work on the machines.  Noticing that the machine classes had very similar structure, I created a generic machine that I could sort of fill-in-the-blanks with.  This dramatically reduced the boilerplate in most my machines. Some machines were special cases, such as the ``word'' machine that produces both reserved word and identifier tokens.  Continuing to work upwards, I implemented the symbol table, then the logic to feed lines to machines.  Finally, I added logic to print to the token file, and added error printing functionality to the listing file.

\section{Discussion and Conclusions}\label{conclusions}

I'm glad that I chose to program this in Scala, as I feel I've already learned a lot about the language.  I've made several mistakes due to my unfamiliarity with the language, but I noticed and fixed the bugs during testing.  I'm happy with how my program is designed, and even though I'm not 100\% sure what the upcoming projects have in store, I'm confident that my program is modular enough that it will be straightforward to indroduce new features to.

\section{References}\label{ref}

\begin{itemize}
    \item Handouts and lextures from class
    \item API documentation for both Java and Scala
    \item Discussions between myself, Steven Buchele, and James Rogers
\end{itemize}

\section{Appendix I: Sample Inputs and Outputs}\label{sample}

Two source programs were ran through the lexer. The first, ``test1\_correct.pas'', has no lexical errors.  The second, ``test2\_error.pas'', has every lexical error possible.

\filelisting[language=pascal]{test1_correct.pas}
\filelisting{test1_correct.pas.listing}
\filelisting{test1_correct.pas.tokens}
\filelisting[language=pascal]{test2_errors.pas}
\filelisting{test2_errors.pas.listing}
\filelisting{test2_errors.pas.tokens}

\section{Appendix II: Program Listings}\label{code}

\datalisting{operators.dat}
\datalisting{punctuation.dat}
\datalisting{reservedwords.dat}

\scalalisting{net/michaelripley/Util.scala}
\scalalisting{net/michaelripley/pascalcompiler/Lexeme.scala}
\scalalisting{net/michaelripley/pascalcompiler/Lexer.scala}
\scalalisting{net/michaelripley/pascalcompiler/LineFragment.scala}
\scalalisting{net/michaelripley/pascalcompiler/LineLocation.scala}
\scalalisting{net/michaelripley/pascalcompiler/ReservedStrings.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/Identifier.scala}
\scalalisting{net/michaelripley/pascalcompiler/identifiers/SymbolTable.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/CatchAllTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/CompoundTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/SimpleTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/StringTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/Tokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokenizers/WordTokenizer.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/AttributeToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/ErrorToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/IdentifierToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/PartialAttributeToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/PartialErrorToken.scala}
\scalalisting{net/michaelripley/pascalcompiler/tokens/Token.scala}

\end{document}
